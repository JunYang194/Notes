# HTTP 篇

## 1. 跨域，如何解决跨域请求

原因：浏览器的同源策略

跨域：浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议等不同，都是跨域，是浏览器施加的安全限制。

解决：`cors`跨域，`jsonp`跨域，`http`代理跨域

## 2. get和post的区别

1.最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

2.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

3.GET请求只能进行url编码，而POST支持多种编码方式（form表单，文件，json字符串，xml）。

4.GET请求在URL中传送的参数是有长度限制的，而POST没有。

5.GET的参数或直接暴露在URL上，相对POST更不安全

## 3. token

认证令牌

场景：用户登录成功后，需要反复到服务器获取敏感数据，服务器每次请求都要验证是哪位用户发的，且用户是否合法，需要反复查询数据库，对数据库造成过大压力

具体流程：用户登录成功后，在服务器可以查询到此用户的相关信息，服务器通过一些加密算法把用户信息，token的有效期等，加密成一个字符串，然后发送给用户，这个字符串就是token，加密算法只有服务器知道，服务器可以对token进行解密，还原成原始值

重点：用户每次请求都必须携带token，服务器直接解密token就可以知道用户的相关信息，省去查询数据库的操作，减轻数据库压力

## 4. http状态码

- 200：请求成功
- 301：资源被永久转移到了其他URL
- 302：资源被临时转移到了其他URL
- 404：请求的资源不存在
- 500：服务器端错误

## 5. 发送请求的传参方式

- 查询字符串：`/detail?lid=5`，query获取
- 路由传参：`/detail/5`，parmas获取
- POST传参：需要结合body-parser，body获取

## 6. http和https的区别

- HTTP的URL以http://开头，HTTPS的URL以https://开头
- HTTP是明文传输，HTTPS是加密传输
- HTTP的端口号是80，HTTPS的端口号是443
- HTTP协议免费申请，HTTPS协议一般是需要付费购买

## 7. AJAX的原理及实现步骤

AJAX：HTTP协议的异步通信

通过XMLHttpRequest对象来向服务器异步发送请求，从服务器获得数据，然后用JS操作DOM将数据更新到页面

实现步骤：

- GET请求：
  1. 创建一个XMLHttpRequest对象
  2. 调用该对象的open方法
  3. 设置回调函数onreadystatechange = callback
  4. send
- POST请求：
  1. 创建一个XMLHttpRequest对象
  2. 调用该对象的open方法
  3. 调用setRequestHeader("Content-Type","application/x-www-form-urlencoded");
  4. 设置回调函数onreadystatechange = callback
  5. send

## 8. AJAX超时断开

当进行前后端通信时，如果响应没有设置结束导致请求一直处于挂起状态，或者超出了我们设置的时间，就会发生通信超时

可以通过设置请求的timeout属性来设置超时时间:`request.timeout = 2000`，必须设置在open方法之后，send方法之前

当超时发生时，timeout事件将会被触发:`request.addEventListener(“timeout”,timeoutHandler)`

当超时发生后，我们需要断开通信连接，需要使用abort方法:`request.abort()`

```javascript
let xhr = XMLHttpRequest();
xhr.addEventListener("readystatechange", readyStateChangeHandler); xhr.addEventListener("timeout", timeoutHandler); //侦听超时事件

xhr.open("POST", "http://10.9.72.236:4010");
xhr.timeout = 5000; //设置超时时间
xhr.send("a=1&b=2"); 

function readyStateChangeHandler(e) { 
  if (xhr.readyState === 4 && xhr.status === 200) { 
    console.log("通信完成并且成功"); 
  } else if (xhr.readyState === 4) { 
    console.log("通信完成，但是通信可能有误"); 
  } else { 
    console.log("通信的过程"); 
  } 
}
function timeoutHandler(e) { 
  console.log("超时了"); 
  xhr.abort(); //断开连接
}
```

## 9. Restflu的请求有哪些方式

- GET：一般用于请求资源
- POST：一般用于新建资源(也可用于更新资源)
- PUT：一般用于更新资源
- DELETE：一般用于删除资源

## 10. WebSocket和http协议相比有什么优点

WebSocket：全双工通信

- 支持服务器端向客户端推送消息，而不用等待客户端的请求
- 可以一直保持连接，和http相比不但每次连接的总开销少了，而且WebSocket的首部信息量也小，通信量也少了

## 11. jsonp和cors

- JSONP：发送的不是AJAX请求，通过动态创建script标签来跨域，只能用来获取资源（get请求），对浏览器支撑性好
- cors：就是使用 XHR 对象，发送Ajax请求，来进行跨域的资源共享，支持所有的http请求，支持主流浏览器，不支持IE10以下

## 12. cors发送两个请求干了什么

- 第一次请求是一种“预检”请求，是对服务器端的一种权限请求，只有预检请求成功返回，才会执行正式请求
- 第二次是执行真实请求，携带真实数据发送

--------

# HTML 篇

## 1. H5新特性

1. 语义化标签  
2. 增强型表单 
3. 视频和音频   
4. canvas绘图   
5. svg矢量图  
6. 地图API  
7. drag拖放   
8. webworker，是一种运行在后台的javascript脚本，不会影响页面性能  
9. webstorage（sessionStorage会话存储，localStorage持久性存储）
10. websocket

## 2. 说一下对HTML语义化标签的理解

语义化就是选择与语义相符合的标签，使代码语义化，这样不仅便于开发者进行阅读，同时也更方便维护代码，还能够让搜索引擎和浏览器等工具更好地解析。

通俗的讲语义化就是让正确的标签做正确的事情，比如段落用p标签，头部用header标签，主要内容用main标签，侧边栏用aside标签等等。

## 3. src和href的差别

- src：src指向的内容会嵌入到文档当前标签所在位置，如img，script等
- href：表示超文本引用。用来建立当前元素和文档之间的链接

----------

# CSS 篇

## 1. 对BFC规范(块级格式化上下文：`block formatting context`)的理解？

- 是一块区域 body 根元素
- 浮动元素：除`float:none`以外的值
- 定位元素：`position:absolute/fixed`
- display：`display:inline-block/table-cells/flex`
- overflow：`hidden/auto/scroll`


## 2. 上下`margin`重合的问题


## 3. 设置元素浮动后，该元素的`display`值是多少？

`block`

## 4. `display:inline-block` 什么时候会显示间隙？

间隙产生的原因是因为，换行或空格会占据一定的位置

解决方法:
父元素设置:`font-size:0;`

## 5. 元素竖向的百分比设定是相对于容器的高度吗？

对于子元素的高度百分比依赖父元素的高度
对于竖直方向的`margin`和`padding`，参照父元素的宽度

## 6. 讲讲flex布局

`flex`布局:弹性布局,分为弹性容器和弹性项目,通过指定容器主轴和交叉轴方向以及项目的对齐方式,可以灵活对容器中的项目进行排列布局,并可以随着页面大小的改变自适应页面布局。

指定弹性布局后,子元素的的`float`、`clear`等属性将失效;

## 7. 如何水平垂直居中

1. 固定宽高：使用绝对定位+margin
2. 相对大小：使用相对定位+`transform: translate(-50%, -50%)`，存在兼容性问题
3. 弹性布局：主轴和交叉轴上居中`display:flex;justify-content: center;align-items: center;`
4. 使用table-cell：`display:table-cell;text-align:center;vertical-align: middle;` 不存在兼容性问题

## 8. C3新特性

1. 渐变  
2. 过渡  
3. 媒体查询  
4. 2D  3D转换   
5. 弹性布局

## 9. 清除浮动的方法

1. 直接设置父元素的高度，缺点是：不是每次都知道父元素的高度
2. 设置父元素也浮动，缺点是：父元素不总是需要浮动的，设置浮动会影响到其他元素
3. 为父元素设置overflow属性，但如果有内容需要溢出显示的话，也会一同被隐藏
4. 在父元素中，追加空子元素，并设置其clear:both，但页面中会多出一个空元素
5. 用内容生成的方式，`::after{ content:"" ; display:block; clear:both }`

## 10. 谈一下盒模型

- 盒模型包括：content，padding，border，margin
- 盒模型分为：IE盒模型（怪异盒模型），标准W3C盒模型
- IE盒模型宽度包括padding和border，W3C盒模型宽度就是内容宽度

## 11. `display:none`和`visibility:hidden`的区别？

- `display:none`：隐藏后的元素无法点击，无法使用屏幕阅读器等辅助设备访问，占据的空间消失
- `visibility:hidden`：隐藏元素仍需占用与未隐藏时一样的空间，也就是说虽然元素不可见了，但是仍然会影响页面布局

## 12. animation 和 transition 的区别

1. transition是过渡，是样式的变换，只有开始和结束的状态；animation也叫关键帧，通过和 keyframe 结合可以设置中间帧的一个状态
2. animation 配合 @keyframe 可以不触发事件就开始这个变化过程，而 transition 需要通过 hover 或者 js 事件来配合触发
3. animation 可以设置很多的属性，比如循环次数，动画结束的状态等等，transition 只能触发一次

## 13. link和import的不同

1. 使用方法不同：link一般在html头部定义，作为html标签，链接资源，主要用于链接外部的样式表；import一般定义在css内部，并且一定要在其他所有规则之前，也就是一般写在文件头部，并且专门拿来链css的
2. import比link延迟一些，它会等到页面下载完后才加载，因而可能会产生闪烁

## 14. CSS哪些属性可以被继承

`font-size`,`font-family`,`color`,`background`等

## 15. 优先级算法如何计算

- !important>ID选择器>类选择器>标签选择器
- 内联样式>内部样式>外部样式
- !important优先级高于内联样式

## 16. CSS3新增伪类选择器

- :first-child 选择属于其父元素的首个元素。
- :last-child 选择属于其父元素的最后一个元素。
- :only-child 选择属于其父元素唯一的元素。
- :nth-child(n) 选择属于其父元素的任意一个子元素。
- :empty 选择没有子元素的元素。
- :not(selector) 将满足指定选择器的元素给排除在外

## 17. 为什么要初始化CSS样式

因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有的CSS初始化可能会出现浏览器之间的页面显示差异

## 18. 栅格布局的原理

随着屏幕视口（viewport）尺寸的增加，系统会自动分为最多12列（也可以自己订制分为多少列）。

通过一系列的行（row）与列（column）的组合创建页面布局

通过定义容器大小，平分12份，再调整内外边距，最后结合媒体查询，实现强大的栅格布局系统

## 19. 用CSS画一条0.5px的线

```html
<style lang="scss">
  .parent{
    /* 相对定位 */
    pasition:relative;
    ::after{
      /* 绝对定位到最底部 */
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      /* 画一个边框为1px的元素 */
      content:'';
      box-sizing:border-box;
      height:1px;
      border:1px solid rgba(0,0,0,.2);
      /* 元素Y方向缩小为原来的0.5倍，并更改元素变形的原点 */
      transform:scaleY(0.5);
      transform-origin:0,0;
    }
  }
</style>
<div class="parent"></div>
```

## 20. PC端与手机端的适配

关键词：媒体查询

- bootstrap这种框架就是依赖媒体查询，实现布局随设备宽度自动切换
- 字体大小，元素大小都使用rem这种相对单位，不使用px这种绝对单位
- 关键标签：`<meta name=”viewport" content="width=device-width,initial-scale=1"`
- 尽量使用流动布局方式
- 根据屏幕宽度，加载不同的CSS文件
- 图片的自动缩放，例如`img{max-width=100%}`，根据不同屏幕分辨率加载不同大小的图片

## 21. rem是什么

是指相对于根元素的字体大小的一个相对单位，最合适的场景就是移动端网页，根据设备自动更改根元素字体大小，就可以实现全局的自动适配

## 22. flex布局用过哪些属性

- `flex-direction`：更改主轴方向
- `flex-wrap`：是否换行
- `justify-content`：主轴方向上的对齐方式
- `align-items`：交叉轴方向上的对齐方式
- `align-self`：弹性项目单独在交叉轴方向的对齐方式

## 23. 列举块级元素，行内元素，行内块元素有何区别

块级元素：

- 独占一行，其后的元素也只能另起一行
- 高度、宽度、行高和顶底边距（内外）都是可以设置的
- 宽度如果不设置的话，默认为父元素的宽度
- 高度靠内容撑开，如没有内容高度为0

行内元素：

- 和其他行内元素共用一行
- 高度、宽度不可设置，默认宽度为内容宽度
- padding只对左右下有效，margin只对左右有效

行内块元素：

- 元素在一行上显示
- 可以给行内块元素设置宽度和高度


----------

# JS 篇

## 1. 数组方法`pop()` `push()` `unshift()` `shift()`

```javascript
arr.pop()  //删除数组末尾的一个元素，返回删除的元素
arr.push()  //往数组的末尾添加元素，返回数组的长度
arr.unshift()  //往数组的开头添加元素，返回数组的长度
ar..shfit()  //删除数组开头的一个元素，返回删除的数组
```

## 2. `==`和`===`的不同

> `==`: 只做值的比较,不做类型的比较
>
> `===`:  做值和类型的比较

## 3. 函数声明与函数表达式的区别？

 - 函数声明会被声明提前到当前作用域最顶端,可以在声明前调用;函数表达式仅提升变量名,所以必须在创建后调用
   - 函数声明必须有函数名,函数表达式可以没有函数名(匿名函数)

## 4. `Promise`的实现

## 5. 冒泡排序算法

```javascript
var arr = [10, 9, 30, 20, 100, 88];
for (var i = 0; i < arr.length - 1; i++) {
  for (var j = 0; j < arr.length - 1 - i; j++) {
    if (arr[j] > arr[j + 1]) {
      var n = arr[j + 1];
      arr[j + 1] = arr[j];
      arr[j] = n;
    }
  }
}
console.log(arr);
```

## 6. ES6新语法

 - `let;const`
 - 箭头函数
 - 模板字符串
 - `for of`
 - 参数增强
 - 解构
 - `class`
 - `promise`

## 7. 怎样给数组添加或删除新元素

```javascript
//添加
arr.push();  //往数组的末尾添加元素
arr.unshift();  //往数组的开头添加元素

//删除
arr.pop();  //删除数组末尾的一个元素
arr.shift();  //删除数组开头的一个元素
arr.splice();  //删除指定位置，指定长度的元素
```

## 8. 什么是闭包，对闭包的了解

外层函数被调用后，外层函数的作用域对象被内层函数引用着，无法释放，就形成了闭包

内层函数（闭包函数）总是可以访问其所在外层函数中声明的参数和变量，即使在外部函数执行完毕

闭包的实质是因为函数嵌套而形成的作用域链

闭包的优点：重用，防止全局污染

闭包的缺点：占用内存大，使用完后因尽快释放`内层函数=null`

## 9. 对`Promise`的理解

保证多个异步任务可以按顺序执行，避免了层层嵌套的回调函数，避免调地狱问题，

三种状态：

- padding：挂起/等候状态
- fulfilled：成功状态
- rejected：失败状态

优势：既可按顺序执行，又不会产生嵌套

缺点：无法取消，一旦调用就会立即执行，中途无法取消；如果不设置回调函数，则会抛出错误，不会反应到外部

`Promise.all`：当全部对象执行完成状态后再进行结果的输出，提供了简洁的API，使控制异步操作更加容易

## 10. 判断对象是否是数组

```javascript
let obj=[];
//使用原型对象判断
//1.对比对象的__proto__和数组的prototype
console.log( obj.__proto__==Array.prototype );

//2.使用getPrototypeOf函数判断
console.log( Object.getPrototypeof(obj)==Array.prototype );

//3.使用isPrototypeOf函数判断
console.log( Array.prototype.isPrototypeOf(obj) );

//使用构造函数判断
//4.调用原型对象的constructor判断
console.log( obj.constructor==Array );

//5.使用instanceOf判断
console.log( obj instanceof Array );

//以上方法有瑕疵，如果对象更改了自己的原型对象，就无法成功判断
//6.使用call来调用顶级原型对象中的toString方法，输出对象类型
console.log( Object.prototype.toString.call(obj)==="[object Array]" );

//7.使用ES5中新函数isArray函数来判断
console.log( Array.isArray(obj) );
```

## 11. JS变量函数声明提前

在程序正式执行之前：

会将`var`声明的变量提升到当前作用域的顶部，赋值留在原地

会将`function`声明的函数整体提升到当前作用域的顶部。

## 12. 数组去重

① for循环嵌套，利用splice去重

```javascript
var arr = [1,3,4,5,6,5,6,6,6,4];
//想要进行数组去重，就是要通过循环遍历的方法，让每个数字都与他之后的数字进行比较，写出循环表达式
for(var i = 0 ; i < arr.length ; i++){
  for(var j = i+1 ; j < arr.length ; j++){
    //arr[j]需要从arr[i]后面的第一个数字开始进行比较,所以设置为j = i+1
    if(arr[i] == arr[j]){
    //调用splice方法，这个方法返回的就是修改之后的数组，所以不必再进行数组的其他操作
    arr.splice(j,1);
    //删除下标为j对应的元素,并且删除的个数只为1个
    j--;
    //删除操作完成后，如果不设置此操作，j开始执行下一次循环，值会加1，从而会跳过删除之后紧跟arr[j-1]的一个元素，避免多个元素相邻却无法实现去重的效果；          
    }        
  }
}
console.log(arr);//[1,3,4,5,6]
```

② 创建新数组，用indexOf去重

```javascript
var a=[1,1,2,2,3,2,5,3,9,5,8]
var b=[];  //准备一个新数组
for(var i=0;i<a.length;i++){
	if(b.indexOf(a[i])==-1){
		b.push(a[i]);
	}
}
```

③ 用ES6中set去重

```javascript
function newArr(arr){
  // return Array.from(new Set(arr))
  // 或
  return [...new Set(arr)]
}
var arr = [1,1,2,9,6,9,6,3,1,4,5];
console.log(newArr(arr))
```

## 13. 作用域链

函数对象中保存函数调用时所有可用的作用域对象的链式结构

存储着一个函数可用的所有变量（局部变量和全局变量）

作用域链控制着: 变量的使用顺序（先局部后全局）

## 14. 原型链

由多级父对象，逐级继承，形成的链式结构，原型链保存着一个对象可用的所有属性和方法

原型链控制着属性和方法的使用顺序：先自有，再共有——就近原则

## 15. 面向对象：封装，继承，多态。原理和应用

封装：创建一个对象集中保存一个事物的属性和功能，便于大量数据的管理和维护，只要使用面向对象方式编程，都要先创建对象。

继承：父对象中的成员，子对象无需重复创建，就可直接使用！同一类型的所有子对象，都需要相同的方法定义或属性值时，都会用继承的方式来实现。 

多态：

重载(overload)：一个函数，根据传入的实参值不同，执行不同的逻辑

重写(override)：在子对象中定义一个和父对象中成员同名的属性或方法！使用时则优先使用自己的属性或方法

## 16. 原型对象

替所有子对象保存共有方法和属性值的父对象

当new一个新对象时，new会自动让新子对象继承构造函数的原型对象。自动设置子对象的`__proto__`属性指向构造函数的原型对象。

## 17. 深拷贝和浅拷贝

浅拷贝：只能实现对值的复制，对于引用类型的对象来说，浅拷贝是对对象地址的复制，复制后两个对象指向同一个地址，修改一个对象的属性则另一个对象的属性也会改变

深拷贝：拷贝对象的具体内容，地址不一样，互不干涉

实现深拷贝：

① JSON内置的方法：该方法是用JSON.stringify将对象转为字符串，然后在用JSON.parse转回对象，json字符串转换为对象的时候，会自己去构建新的内存地址存放数据

```javascript
let oldObj = { a: 1 }
let newObj = JSON.parse(JSON.stringify(oldJson))
oldObj.a = 2
console.log(oldObj) // {a: 2}
console.log(newObj) // {a: 1}
```

② 递归实现

```javascript
let obj = { name: 'wanxin', age: 25, home: { a: '四川', b: '达州' } };

function clone(obj) {
	if (obj === null) return null;
  if (typeof obj !== 'object') return obj;
  let newObj = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
      newObj[key] = clone(obj[key]);
    }
    return newObj;
  }
let obj2 = clone(obj);
console.log(obj.home == obj2.home); //false
```

## 18. 普通函数和箭头函数的区别

① this方面

- 普通函数内部this默认指向window，严格模式下指向undefined
- 箭头函数内部this与上一级作用域中的this指向一致（和外部保持一致）

② arguments方面

- 普通函数可以通过`arguments`来实现重载
- 箭头函数没有`arguments`

③ 原型对象方面

- 普通函数有原型对象
- 箭头函数没有原型对象

④ new方面

- 普通函数可以作为构造函数，通过new实例化出子函数；
- 箭头函数不能作为构造函数，不能使用new

## 19. 解构

解构赋值是对赋值运算符的扩展;

- 数组解构：下标对下标，提取出数组中个别元素值，单独使用
- 对象解构：属性对属性，取出对象中个别属性值或方法，单独使用, 等号左边属性名和变量名一致时.可简写
- 参数解构：定义时,形参使用对象解构,属性名和变量相同时,可简写属性名='默认值'，调用时,给需要修改的参数提供实参值,不需要修改则不传参

## 20. 如何保证axios同步执行

async / await来实现axios进行同步请求

```javascript
async created () {
	await this.axios.POST('URL',data).then(result=>{
    console.log(result)
  })
}
```

## 21. JS的数据类型

- 基本类型：string、number、boolean、undefined、null、Symbol
- 引用类型：Function、Object、Array

## 22. var，let，const的区别

- var存在声明提前，let和const不存在
- var仅在function中声明才是局部变量，其他都是全局变量，let一直都是局部变量
- 同一作用域下，var允许重复声明，let和const不允许

## 23. null和undefined的区别

- null表示没有指向一个对象
  - 主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址
  - 作为对象原型链的终点
- undefined表示缺少值
  - 定义了形参，没有传实参，显示undefined
  - 对象属性名不存在时，显示undefined
  - 函数没有返回值，显示undefined
  - 写了返回值，但没有赋值，显示undefined

## 24. 如何理解json

JSON是JS对象的一种表达方式，以JS对象的数据格式展现出来的字符串，两个常用API：

将JSON字符串转换成JSON对象：`JSON.parse()`

将JSON对象转换成JSON字符串：`JSON.stringify()`

## 25. this指向

- 调用时，this自动指向当前.前的对象
- 调用构造函数时，构造函数中的this指向正在创建的对象
- function中，this默认指向window
- 访问器属性中的this指向访问器属性添加到的当前对象
- DOM的事件处理函数中的this指向正在触发事件的DOM元素对象
- Vue中this指向Vue对象

## 26. 怎么改变this指向

- 临时替换一次this，使用call函数
- 临时替换一次this，但需要打散数组再传参时，使用apply函数
- 创建一个一模一样的新函数并永久绑定this和部分实参值，使用bind函数

babel工具

## 27. promise和async/await的区别

区别主要在于按顺序调用多个异步函数的语法和报错获取

```javascript
//promise
axios().then(func1).then(func2).then(func3).then(func4).catch(err=> console.log(err) )

//await/async方方式
async function demo(){
  try{
    await res = ajax();
    await res = fun1(res);
    await res = fun2(res);
    await res = fun3(res);
    await res = fun4(res);
  }catch(err){
    console.log(err)
  }
}
```

总结：

- 当遇到多个异步函数时
  - Promise方式需要很多`.then()`，会导致代码不易读 且 结构复杂
  - async/await方式让异步代码的格式与结构 与 同步代码一样，更易读
- 错误处理
  - Promise使用`.catch`抓取报错
  - async/await使用`try...catch...`抓取报错

## 28. 数组常用方法

```javascript
arr.map();  //保护原数组不变，返回遍历加工后的新数组
arr.forEach();  //单纯简化for循环变量原数组中每个元素,无返回值
arr.filter();  //过滤，将满足条件的元素组合成一个新的数组返回
arr.every();  //判断是否数组中所有元素都符合要求,返回布尔值
arr.some();  //判断数组中是否包含符合要求的元素,返回布尔值
arr.reduce();  //遍历数组中每个元素，经过求和或其他汇总方式，统计出一个最终结果并返回
arr.push();  //在数组末尾新增元素，返回数组的长度
arr.pop();  //删除数组最后一个元素，返回删除的元素
arr.shift();  //删除数组第一个元素，返回删除的元素
arr.unshift();  //在数组开头新增元素，返回数组的长度
arr.concat:  //将多个数组拼接成一个新数组
arr.toString();  //将数组转为字符串
arr.join();  //将数组转为字符串，可以自定元素之间的分隔符，默认是按照逗号分隔
arr.splice(start,count);  //删除数组中的元素,start=开始的下标，count=删除的长度
```

## 29. set和map数据结构

set和map是ES6新增特性

map映射 ，一个键值对结构，类似与JS的对象类型

```javascript
let map = new Map();
map.set('name','东东')；
map.set('age','22');
map.set('gender',1);
console.log(map);  //Map(3) { 'name' => '东东', 'age' => '22', 'gender' => 1 }
console.log(map.get('name'));  //东东
```

set集合：特点为内部元素不会重复，会自动去重

```javascript
let a = new Set([1,2,3,4,3,2,1]);
console.log(a);  //set{1,2,3,4};
```

## 30. 防抖与节流

在开发过程中，如果非频繁调用事件处理函数内的复杂计算，可能会造成页面的卡顿，我们更希望把多次计算合并成一次，只进行一次操作，成为防抖和节流

防抖：

当持续触发事件时，一定时间内没有再触发事件，比如5秒，事件处理函数才会执行一次，如果在5秒内，再次触发了事件处理函数，就会重新开始计算时间。也就是当一个用户一直触发这个函数，并且每次触发的间隔时间小于5秒，name防抖的情况就会只执行一次

```javascript
function debounce(fn,wait){
  let timeout = null;  //定义一个定时器
  return function(){
    if(timeot != null) clearTimeout(timeout);  //清除这个定时器
    timeout = setTimeout(fn,wait);
  }
}
//处理函数
function handle(){
  console.log(Math.random());
}
//滚动事件
window.addEventLinstener('scroll',debuounce(handle,1000));
//效果：
//页面停止滚动1秒后，才会打印随机数字
//在滚动过程中并没有持续执行，有效减少了性能消耗
```

节流：

当持续触发事件时，保证在一定时间内只调用一次时间处理函数，假设一个用户一直触发这个事件，且每次触发小于既定值，函数节流会每隔这个时间调用一次

```javascript
let throttle = function(func,delay){
  let timeout = null;
  return function(){
    let context = this;  //this指向window
    let args = arguments;
    if(!timeout){
      timeout = setTimeout(function(){
        func.apply(context,args);
        timeout = null;
      },delay);
    }
  }
}
function handle(){
  console.log(Math.random());
}
window.addEventLinstener('scroll',throttle(handle,1000))
```

**总结：**

防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行

## 31. 严格模式和非严格模式的区别

严格模式：使用`use strict`指令开始严格模式

主要区别：

- 变量必须先声明，后使用
- 不能使用`delete`关键词删除变量或对象
- 函数的参数名不能重复
- 对象的属性名不能重复
- 静默失败升级为报错
- 普通函数中的this指向undefined
- arguments的区别：

```javascript
"use strict";
function fn(a,obj){
  arguments[0] = 2; 
  arguments[1].b = 2; 
  console.log(a); // 严格模式为1；非严格模式为2 
  console.log(obj.b); // 2,因为js中object是地址传递
}
fn(1, { b: 1 });
```

## 32. call，apply，bind的区别

- call：替换函数中的this为第一个参数，并将剩余参数依次传入函数，立即执行
- apply：替换函数中的this为第一个参数，并将剩余参数放到数组中传入函数，立即执行
- bind：替换函数中的this为第一个参数，并可以永久绑定其他参数，返回新的函数，刽直接触发函数

## 33. 手写一个递归函数

```javascript
function fib(n){
  if(n<=2){
    return n
  }else{
    return fib(n-2)+fib(n-1)
  }
}
console.log(fib(5))
```

## 34. 手写一个验证手机号的正则

```javascript
//简单规则：首位1，第二位3-9，剩余九位3~9
let reg = /^1[3-9]\d{9}$/
```

## 35. 同步和异步的区别

- 同步：在执行某项任务时，必须等任务执行完毕才会继续执行后续任务(阻塞模式)
- 异步：在执行某项任务时，后续任务不需要等待此任务执行完毕，而是继续往下执行(非阻塞模式)

## 36. ES6新增数组函数

- Array.from()：将类数组对象转为数组，如arguments，DOM对象等
- Array.of()：把参数合并成一个数组返回，如果参数为空，则返回一个空数组
- arr.find()：查找符合条件的第一个数组成员，没找到就返回undefined
- arr.findIndex()：查找符合条件的第一个数组成员对应的索引值，没找到返回-1
- arr.fill()：用于填充数据，主要有三个参数，用法是arr.fill(填充的东西,从哪开始填充,不包含的结束位置)
- arr.includes()：判断一个数组是否包含一个指定的值，包含就返回 true , 否则返回false
- ...

```javascript
//Array.from()
let fruits = {
	0:'apple',
	1:'banana',
	2:'orange',
	length:3
};
let arr = Array.from(fruits);
console.log(arr);  //[ 'apple','banana','orange' ]

//Array.of()
let arr = Array.of('apple','banana','orange')
console.log(arr);  //['apple','banana','orange']

//arr.find()
let arr = [1,2,3,4,5];
let res = arr.find(function(val,index,arr){
	return val > 3
})
console.log(res); //4

//arr.findIndex();
let arr = [1,2,3,4,5];
let res = arr.findIndex(function(val,index,arr){
	return val > 3
})
console.log(res); //3

//arr.fill()
let arr = new Array(4);
arr.fill('张三');
console.log(arr);  //['张三','张三','张三','张三']
let arr2 = new Array(4);
arr2.fill('张三',1,3);
consoloe.log(arr2);  //[empty,'张三','张三',empty]

//arr.includes()
let arr = [1,2,3,4,5];
console.log(arr.includes(2)); // true
console.log(arr.includes(6)); // false
```

## 37. 回调函数中的this指向

事件处理函数：

- 普通函数：this指向当前DOM对象
- 箭头函数：和上级作用域this指向相同

其他：

- 普通函数：this指向window对象
- 箭头函数：和上级作用域this指向相同

## 38. node是同步还是异步的？单线程还是多线程？

待定

## 39. undefined==null 返回结果为什么

```javascript
console.log(undefined==null);  //true
console.log(undefined===null);  //false
```

undefined和null都表示一个无效的值，那么它们所表示的内容也具有相似性，所以在`==`的情况下返回结果为`true`，如果是`===`的情况下，返回结果为`false`

## 40. JS中哪些数据会被转为false

Undefined、null、 false、NaN、零、空字符串

## 41. map方法传入函数的this指向

如果为只给map传入一个回调函数，则这个回调函数中的this默认指向window

可传入第二个参数为回调函数的this绑定一个对象

## 42. Promise常用方法

`Promise.resolve`

- Promise.resolve()方法在回调时被调用直接返回一个fulfilled状态的Promise对象

`Promise.reject`

- Promise.reject()方法在回调时被调用直接返回一个rejected状态的Promise对象

`Promise.all( [p1,p2,p3] ).then(res=>console.log(res))`

- 只有当传入的promise对象状态都变成`fulfilled`，才会调用.then函数，此时数个promise的返回值组成一个数组，传递给.then中的参数。
- 只要其中一个promise对象被`rejected`，就会调用.catch函数，此时第一个被`reject`的实例的返回值，会传递给.catch的参数。

`Promise.any( [p1, p2, p3] )`

- p1, p2, p3有一个fulfilled就会fulfilled，全部rejected才会rejected

## 43. Promise.resolve().then(callback1).then(callback2),会执行几次

Promise.resolve()调用会立即执行第一个.then内的回调函数

- 如果这个回调函数不是一个不会返回promise对象，则会继续执行第二个.then函数
- 如果这个回调函数时一个promise对象，并且为fulfilled状态时，才会继续执行第二个.then函数

## 44. for循环，for of，for in，forEach有什么区别

for循环：

- 可遍历索引数组，类数组对象
- 没有可简化空间

for of：

- 可遍历索引数组，类数组对象，字符串
- 只能获得元素值，不能获得元素下标
- 无法修改遍历的顺序和步调

for in：

- 可遍历自定义下标的关联数组，对象

forEach：

- 专门遍历索引数组
- 无法遍历类数组对象
- 可以配合ES6箭头函数，语法简洁

----------

# DOM 篇

## 1. 回流和重绘

当DOM的变化影响了元素的几何属性（宽或高），浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排,完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘

## 2. DOM优化

- 减少重排重绘
- 操作顺序：尽量在appendChild前添加操作
- 合并dom操作：利用cssText ，就是把改变的样式写在一起
- 缓存布局信息
- 文档片段

## 3. jQuery的特点和好处

- 一个函数两用
  - 没给新值作为参数，默认执行获取旧值的操作
  - 给了新值作为参数，自动切换为执行修改操作
- 链式操作
- 自带for循环
- 兼容大部分浏览器

## 4. jQuery链式操作的原理

```javascript
// 语法
$('#ID').css().append().xxx()
```

原理：每个函数调用后的返回值，都是当前对象，主要依赖每个函数结尾的`retuen this`

## 5. 事件模型

捕获：从根节点开始，到当前触发事件的目标元素，记录各级元素是否绑定了事件处理函数，只记录，不执行

目标触发：优先触发实际点击的目标元素(target)的事件处理函数

冒泡：从目标元素开始，到根节点结束，从内向外依次执行各级元素上绑定的事件处理函数

## 6. 事件委托

当多个子元素都要绑定相同的事件，可以利用事件委托的方式：

- 事件只在父元素上绑定一次
- e.target代替this
- 通过e.target的任意特征判断是否是我们想要的元素
- 执行事件处理函数

## 7. 阻止默认行为

如链接<a>，提交按钮<input type="submit">等，会有一些默认行为，我们不需要此默认行为时可以进行阻止

- w3c的标准方法是`e.preventDefault()`
- Vue中是`@事件.prevent`
- IE则是使用`e.returnValue = false`

------

# Vue 篇

## 1. vue生命周期钩子函数有哪些？

- vue生命周期：创建，挂载，更新，销毁

```javascript
beforeCreate(){}; //data和methods都未创建，此处不可用
created(){}; //data和methods创建完毕，最早的可以使用处
beforeMount(){}; //内存中已经编译好所有内容，准备显示到页面
mounted(){}; //组件脱离创建阶段，真正显示到页面，操作页面的DOM，最早可以在此处进行
beforeUpdate(){}; //更新前
updated(){}; //更新完毕
beforeDestroy(){}; //销毁前
destroyed(){}; //销毁完毕，data和methods此处消失，无法使用
```

## 2. 请问 v-if 和 v-show 有什么区别？

- v-if：通过删除DOM元素来实现元素的隐藏；只有条件为真时，才会加载元素到DOM树；在条件修改时，消耗比v-show更大
- v-show：通过设置CSS样式：`display:none`实现元素的隐藏，不操作DOM；不管条件为真与假，都会加载到DOM；在初次加载时的消耗比v-if更大
- 一个元素频繁进行 隐藏 和 显示 操作，使用v-show更合适
- 一个元素不频繁进行 隐藏 和 显示 操作，使用v-if更合适

## 3. `vue`中`key` 值的作用

 - 为元素绑定唯一标识
 - 修改时避免了重建整个列表
 - 提高了修改效率

## 4. `vue`中子组件调用父组件的方法

```HTML
<!-- 父组件中 -->
<template>
  <div class="father">
    <child :fatherMethod="fatherMethod"></child>
  </div>
</template>
<script>
  import child from '~'
  export default{
    components:{child},
    methods:{
      fatherMethod(a){
        conlose.log(a)
      }
    }
  }
</script>

<!--子组件中-->
<template>
  <div class="child">
    <button @click='childMethod'>
  </div>
</template>
<script>
  export default{
    methods:{
      childMethod(){
        this.$emit('fatherMethod','参数')
      }
    }
  }
</script>
```

## 5. `vue`中父组件调用子组件的方法

```HTML
<!--父组件-->
<template>
  <div class="father">
    <child ref="child"></child>
    <button @click="fatherMethod"></button>
  </div>
</template>
<script>
  import child from '~'
  export default{
    components:{child},
    methods:{
      fatherMethod(){
        this.$refs.child.childMethod()  //调用子组件方法
      }
    }
  }
</script>

<!--子组件-->
<template>
  <div class="child">
    <button @click="childMethod"></button>
  </div>
</template>
<script>
  export default{
    methods:{
      childMethod(){
        //调用子组件方法
        console.log('子组件的方法被父组件调用了')  
      }
    }
  }
</script>
```

## 6. `vue`组件之间传值

 - 父传子: 父组件通过`:自定义属性名="变量"`的方式传值;  子组件通过`props:['自定义属性名	']`接值,所接受的值`data`中的变量用法完全一样
 - 子传父: 父组件通过`:自定义事件名="事件处理函数"`的方式等待子组件调用并传值; 子组件通过`this.$emit('自定义事件名',实参值)`的方式调用父组件中的事件处理函数
 - 兄弟组件传值: 通过bus中转的方式,先向`Vue`原型对象中添加一个`new Vue`实例`Vue.prototype.bus=new Vue`;  接收方可在`created`中使用`$on`定义一个自定义事件名,并绑定想要调用的事件:`this.bus.$on('自定义事件名',this.要调用的方法.bind(this))`; 传值方使用`$emit`调用自定义事件并传值:`this.bus.$emit('自定义事件名',参数)`

## 7. `vue`中 `keep-alive` 组件的作用

是vue中一个内置组件，由`keep-alive`包裹的组件将被缓存下来,跳转别的页面后,再次返回原页面,防止此组件二次渲染,提升效率

>  场景：
>
>  用户在某个列表页面选择筛选条件的时候过滤出一份数据列表，由列表页面进入数据详情页面，再返回该列表页面，我们希望：列表页面可以保留用户的筛选状态
>
>  参数:
>
>  `icloude`:只有匹配的组件才会被缓存
>  `exclude`:任何匹配的组件都不会被缓存

## 8. `vue` 中`$nextTick` 作用是什么？

在执行某些DOM操作的时候，可能因为DOM并未渲染完成 或 未渲染成最终状态 而导致操作失败，如在`created`钩子函数中操作DOM就是无效的，此时需要将DOM操作的JS代码放进`Vue.nextTick`的回调函数中

例：

```html
<template>
	<div>
    <h3 id="name">{{name}}</h3>
  </div>
</template>

<script>
	export default{
    data(){
      return{
        name:'张三',
      };
    },
    mounted(){
      this.name="李四";
      //由于一步渲染机制，只有把mounted方法执行完毕后，name才会更新到DOM
      let el = ducoment.getElementById('name');
      console.log(el);  //张三
      //使用this.$nextTick()
      this.$nextTick(()=>{
      	//这里是DOM渲染完成后的回调函数
        let el = ducoment.getElementById('name');
        console.log(el);  //李四
      })
    }
  }
</script>
```

## 9. `Vue`的绑定原理

`vue2`：访问器属性+虚拟`DOM`树

采用数据劫持 结合 发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的getter，setter；在数据变动时发布消息给订阅者，触发响应的监听回调

简易实现：

```html
  <body>
    <h1>欢迎</h1>
    <h1>用户名: <span>{{uname}}</span></h1>
    <h2>积分: <span>{{score}}</span></h2>
    
    <script>
      let data = {
        uname: '张三',
        score: 1000,
      };
      // 第一步:为data中每个属性添加Object.defineProperty
      // ES5新函数:获得data中所有属性名
      let keys = Object.keys(data);
      // 遍历data中每个属性,添加访问器属性
      for (let key of keys) {
        Object.defineProperties(data, {
          [`_` + key]: {
            value: data[key],
            writable: true,
            enumerable: false,
          },
          [key]: {
            get() {
              return this[`_${key}`];
            },
            set(value) {
              this[`_${key}`] = value;
              console.log(`${key}的属性值变了!`);
              // 元素值发生变化,自动调用change()方法,扫描虚拟DOM树,找到受影响的元素,更新真实DOM树上对应节点内容
              change(key);
            },
            enumerable: true,
          },
        });
      }
      Object.seal(data);
      // 第二步:构建虚拟DOM树,并完整绑定元素内容
      // 准备数组保存所有可能受影响的元素
      let arr = [];
      // 递归遍历指定父元素下所有内容为{{XXX}}的元素
      function getChildren(parent) {
        // 获取当前父元素下直接子元素
        let children = parent.children;
        for (let c of children) {
          // 如果子元素还有子元素
          if (c.children.length > 0) {
            // 则继续递归遍历子元素的下一级
            arguments.callee(c);
          } else {
            // 否则,子元素没有更子一级的元素,说明当前元素只有内容
            // 遍历data中变量名
            for (let key of keys) {
              // 每遍历一个变量名,就用当前元素的内容和变量名作比较
              // 只有内容{{}}中的变量名和data中某个属性名一致,才有必要将元素添加到虚拟DOM树上
              if (c.innerHTML == `{{${key}}}`) {
                arr.push({
                  elem: c, // 记录元素对象地址
                  innerHTML: c.innerHTML, //记录内容打算变成哪个变量的值
                });
                // 首次扫描时,需要填充页面填写
                c.innerHTML = data[key];
              }
            }
          }
        }
      }
      // 调用,传入body根节点进行遍历
      getChildren(document.body);

      // 3.封装遍历虚拟DOM树并修改内容的方法
      // 根据本次发生变化的属性,查找虚拟DOM中受影响的节点,更新真实DOM树中该节点的内容
      function change(key) {
        // 遍历虚拟DOM树
        for (let obj of arr) {
          // 当前节点的内受当前属性key变化影响时
          if (obj.innerHTML == `{{${key}}}`) {
            // 才更新真实DOM元素中的内容为data中当前key属性的属性值
            obj.elem.innerHTML = data[key];
          }
        }
      }
    </script>
  </body
```

`vue3`：proxy代理对象+虚拟`DOM`树

## 10. `Vue`双向绑定原理

- 结合Vue响应式原理
- 自动绑定`input`或`change`事件
- 表单元素中的值发生改变时,自动调用事件处理函数
- 获得当前表单元素的内容，实时赋值给`data`中的变量

## 11. `Vue`相关的组件之间的通信方式

1. 父组件给子组件传参（props）
2. 子组件给父组件传参（$emit）
3. 创建新的Vue对象（bus）
4. 使用Vuex
5. 使用全局函数

## 12. 路由守卫的用法

什么是：路由钩子函数，在发生路由跳转时，自动执行回调函数

如果希望在跳进一个路由时，自动执行一项任务，在组件解析之前触发导航时调用：（参数to和from都是路由对象Route）

- to ：即将要跳转的目标路由对象
- from ：即将要离开的目标路由对象
- next() ：回调的函数（必须执行），在前置守卫中通过to获取对应参数，判断相对应跳转的组件或者其他操作（如果不写next()函数将进入死循环）

完整的导航解析流程：

- 导航被触发
- 在失活的组件里调用`beforeRouteLeave`守卫
- 调用全局的 `beforeEach` 守卫
- 在重用的组件里调用 `beforeRouteUpdate` 守卫
- 在路由配置里调用 `beforeEnter`
- 解析异步路由组件
- 在被激活的组件里调用 `beforeRouteEnter`
- 调用全局的 `beforeResolve` 守卫 
- 导航被确认
- 调用全局的 `afterEach` 钩子
- 触发DOM更新
- 调用 `beforeRouteEnter` 守卫中传给 `next` 的回调函数，创建好的组件实例会作为回调函数的参数传入

## 13. 观察者模式

当一个变量被修改时，可以自动通知所有关注这个变量的其他对象，让他们自动重新获得这个变量的新值

简易实现：

```javascript
      let data = {
        money: 1000,
        setMoney(money) {
          this.money = money;
          // 只要money被修改,就要调用notifyAll
          this.notifyAll();
        },
        // 凡是进入obserbers数组的对象,自身需写到一个getMoney函数
        observers: [],
        notifyAll() {
          this.observers.forEach((item) => item.getMoney());
        },
      };
      let obj1 = {
        money: 0,
        getMoney() {
          console.log(`obj1得知data的money被改为:` + data.money);
          this.money = data.money;
        },
      };
      let obj2 = {
        money: 0,
        getMoney() {
          console.log(`obj2得知data的money被改为:` + data.money);
          this.money = data.money;
        },
      };
      let obj3 = {
        money: 0,
        getMoney() {
          console.log(`obj3得知data的money被改为:` + data.money);
          this.money = data.money;
        },
      };
      data.observers.push(obj1);
      data.observers.push(obj2);
      data.observers.push(obj3);
      data.setMoney(900);
      console.log(obj1.money, obj2.money, obj3.money)
```

## 14. MVVM

1.模型对象（Model）：专门保存界面所需的所有变量和事件处理函数的对象

2.界面（View）：增强版的HTML+CSS

3.视图模型(ViewModel)：一种专门自动将模型对象中的数据和函数与界面中保持同步的特殊的程序，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。

## 15. MVC是什么

1.Model：数据模型层，是应用程序中用于处理应用程序数据逻辑的部分，通常负责在数据库中存取数据

2.View：视图层，是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的

3.Controller：控制器层，是应用程序中处理用户交互的部分，通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

## 16. 说出至少4种vue中的指令和用法

1. v-once：元素只在首次加在时更新一次内容,之后不会改变

2. v-bind：绑定属性值,可用`:`简写

3. v-model：双向绑定,变量值可更新到页面中现实,页面中需改的值也可返回程序的变量中

4. v-on：绑定事件处理函数，可用`@`简写

5. v-if/v-else：条件渲染

   等等

## 17. 虚拟DOM

虚拟DOM树是为了解决浏览器性能问题，其中只包含可能发生变化的元素，并且虚拟DOM树不会在操作后立即更新DOM，而是将操作后的最终状态保存到JS对象中，再一次性操作DOM数，避免大量的DOM操作

特点：

- 体积小
- 遍历查找快
- 修改效率高
- 避免重复编码

## 18. Vuex是什么

Vuex是一个专门为Vue.js应用程序开发的状态管理模式，集中存储管理应用的所有组件的状态，常用场景：组件的状态共享（是否登录），组件间的数据共享（购物车，token）等

5个核心属性：

1. state：数据存放
2. getters：相当于计算属性
3. mutation：同步操作，修改数据
4. action：用于异步提交mutation操作
5. modules：模块化

## 19. `router-link`和`$router.push`的跳转原理

- `router-link`
  - 会默认渲染为a标签，可以通过tag属性修改其他的标签
  - 自动为a标签添加上click事件，然后执行`$router-push`
- `$router-push`：根据路由配置的mode确认使用hash模式还是history模式实现跳转
  - history：调用`window.history.pushState()`跳转
  - hash：调用`Hashhistory.push()`跳转

## 20. Vue获取数据在哪个生命周期

最早可以在created周期中进行网络请求，因为这里是最早的data和methods加载完毕的时机，而实际开发中，created和mounted发送请求几乎没有差异，所以在created中和mounted中发送都可以

## 21. Vue中的computed特性

计算属性就是当其依赖属性的值发生变化时，这个属性的值会自动更新，与之相关的DOM部分也会同步自动更新。

使用场景：在页面中绑定一些数据，这些数据需要经过处理后再展示，如果直接在页面中进行处理，代码会过于臃肿。此时就把处理数据的逻辑放在计算属性中

```html
<template>
	<div>
    <h3>{{total}}</h3>
  </div>
</template>
<script>
export default{
  data(){
    return{
      goods:[{ name:"iphone12",price:8999,count:4 }],
    }
  },
  computed:{
  	total(){
      let total=0;
      this.goods.forEach(item=>{
        total+=item.price*item.count
      });
      return total;
    }
	}
}
</script>
```

## 22. Vue的wacth是否可以监听数组

能监听：

- 数组的元素增删，如`push` `splice`操作
- 数组元素内部的变化：必须手动开启`deep:true`配置，才能监听到

```javascript
export default{
  data(){
    return{
      emp:[{name:'Lucy',age:22,skills:["Lucy","Lily"]}] 
    }
  },
  methods:{
    change(){
      this.emp[0].name = "lala"; 
      this.emp[0].skills.push(333);
    }
  },
  watch:{
    emp:{
      handler:xx => console.log(xx) ,
      deep:true, //允许监听内容的变化
    }
  }
}
```

不能监听：

- 数组中已有值的替换

```javascript
export default{
  data(){
    return{
      emp:[{name:'Lucy',age:22,skills:["Lucy","Lily"]}] 
    }
  },
  methods:{
    change(){
      // 此操作，替换下标0位置的值，不会被watch监听
      this.emp[0]={name:'222',age=想·333}
    }
  },
  watch:{
    emp:{
     console.log(emp);
    }
  }
}
```

## 23. 路由传参有几种方式

```javascript
//1.直接调用$router.push携带参数跳转
//路由配置
{
  path:'/details/:id',
  name:Details,
  component:Details,
  props:true,
}
//跳转函数
jump(id){
  this.$router.push(`/details/${id}`);
}
//目标组件中接收参数
props:['id'],
data(){},
...

//2.通过路由属性中的name来匹配组件，parmas来传递参数
//路由正常配置
//跳转函数
jump(id){
  this.$router.push({
    name:'/details',
    parmas:{
      id
    }
  })
}
//目标组件中接收参数
this.$route.parmas.id;
  
//3.使用path来匹配路由，然后通过query来传递参数,参数会显示在url后面?id=？
//路由正常配置
//跳转函数
jump(id){
  this.$router.push({
    name:'/details',
    query:{
      id
    }
  })
}
//目标组件中接收参数
this.$route.query.id;
```

## 24. create和mount的区别

create创建阶段，完成所有的数据创建，属性和方法的运算，在此阶段还未开始将数据挂载页面

mount挂载阶段，将所有页面所需数据都挂载到DOM，挂载阶段结束后可以开始操作DOM

## 25. Vue父子组件声明周期执行顺序

```javascript
父beforeCreate-> 父create -> 子beforeCreate-> 子created -> 子mounted -> 父mounted
```

## 26. 路由守卫主要实现方式

① 全局守卫

- 全局前置守卫：beforeEach
- 全局解析守卫：beforeResolve
- 全局后置守卫：afterEach（无next）

② 路由独享守卫

```javascript
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

③ 组件内的守卫

- `beforeRouteEnter`
- `beforeRouteUpdate` (2.2 新增)
- `beforeRouteLeave`

```javascript
const Foo = {
  template: `...`,
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
  },
  beforeRouteUpdate(to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
  },
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}
```

## 27. 组件中，data为什么是函数

当data是一个函数的时候，每一个实例的data属性是互相独立的，不会受影响的，如果是一个对象，组件间属性会有冲突

## 28. Vue生命周期，除了8个钩子函数还有什么

- **activated**：keep-alive 组件激活时调用
- **deactivated**：keep-alive 组件停用时调用
- **errorCaptured**：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

## 29. Vue父组件怎么监听子组件的声明周期

通过BUS中间的方式，父组件中`this.bus.$on('自定义事件名',this.要调用的方法.bind(this))`，子组件中在需要被监听的生命周期钩子函数中：`this.bus.$emit('自定义事件名',参数)`

## 30. Vuex原理

将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新

## 31. mutation和action的差异

① 定位：

- Mutation：专注于修改State，理论上是修改State的唯一途径。
- Action：业务代码、异步请求

② 限制：

- Mutation：必须同步执行
- Action：可以异步，但不能直接操作State

## 32. 路由守卫有哪些实际用途

- 离开页面时，阻止跳转（如未保存修改内容）
- 权限校验（登录判断等）

------

# 小程序篇

## 1. 小程序的生命周期

页面的生命周期

| 属性     | 说明                 |
| -------- | -------------------- |
| onLoad   | 监听页面加载         |
| onShow   | 监听页面显示         |
| onReady  | 监听页面初次渲染完成 |
| onHide   | 监听页面隐藏         |
| onUnload | 监听页面卸载         |

组件的生命周期

| 属性     | 说明                                   |
| -------- | -------------------------------------- |
| created  | 组件实例刚刚被创建时执行               |
| attached | 组件实例进入页面节点时执行             |
| ready    | 组件在视图层布局完成后执行             |
| moved    | 组件实例被移动到节点树另一个位置时执行 |
| detached | 组件实例从页面节点树移除时执行         |
| error    | 组件方法抛出错误时执行                 |

## 2. 小程序的bindtap和catchtap

bind：允许事件冒泡

catch：阻止事件冒泡

## 3. 小程序的文件结构类型

| 文件     | 必需 | 作用             |
| -------- | ---- | ---------------- |
| app.js   | 是   | 小程序逻辑       |
| app.json | 是   | 小程序公共配置   |
| app.wxss | 否   | 小程序公共样式表 |

一个小程序页面分为四个文件组成，分别是：

| 文件类型 | 必需 | 作用       |
| -------- | ---- | ---------- |
| js       | 是   | 页面逻辑   |
| wxml     | 是   | 页面结构   |
| json     | 否   | 页面配置   |
| wxss     | 否   | 页面样式表 |

------

# 项目篇

## 1. 对项目进行过哪些优化

- 懒加载
- 第三方组件库的按需引入
- `v-if` 和 `v-show`区分使用场景
- `v-for` 遍历为`item`绑定`key`

## 2. GIT 常用命令

```shell
git init #初始化
git add 文件名/git add . #暂存
git commit -m "版本描述" #提交版本
git branch #分支
git merge #合并
git clone 地址 #克隆
git fatch #刷新
git pull #更新
git push #上传
```

## 3. 什么是单页面应用

单页面应用全程single page application，简称SPA

通过路由的变更，局部切换页面内容，而不是整个页面的刷新操作

优点：

- 用户体验好，不用刷新页面
- 局部更新，对服务器压力小
- 良好的前后端分离，后端不再负责页面渲染和输出工作

缺点：

- 首次加载耗时长，速度慢

## 4. 权限管理--->未实现

后台管理系统一般都会有权限管理，用来控制用户能访问哪些页面 和 哪些数据接口

整体思路：

后端返回用户权限，前端根据用户权限处理得到左侧菜单；所有路由在前端定义好，根据后端返回的用户权限筛选出需要挂载的路由，然后使用addRotes动态挂载路由

1. 路由定义，分为初始路由和动态路由，一般来说初始路由只有login，其他路由都挂载到home路由之下需要动态加载
2. 用户登录，登录成功后得到token，保存在sessionStorage，跳转到home，此时进入路由拦截根据token获取用户权限列表
3. 全局路由拦截，根据当前用户有没有token和权限列表，进行相应的判断和跳转，当没有token时跳转到login，有token没有权限列表时去请求获取权限等等
4. 使用Vuex管理路由表，根据Vuex动态渲染侧边栏组件

## 5. 页面图片很多，访问很慢，怎么优化

1. 启用web服务的传输压缩，通过压缩减小图片大小，加快数据传输，提高网页加载速度
2. 启用CDN加速
3. 图片懒加载：刚启动时不加载图片，图片暂时使用默认背景，页面加载完毕后再加载图片
4. 使用GIF格式的图片，质量比JPG,PNG略差，但是小很多，对没有特别要求美观的网站比较实用

## 6. 前后端分离的意义

职责分离

后端：

- 提供数据和服务
- 处理复杂的业务
- 关注服务层
- 开发和充分利用服务器的性能

前端：

- 接受数据和服务
- 处理一些小业务，数据，model，view
- 关注客户端页面渲染，性能，交互
- 优化SEO，性能，加载等

多端开发

- 前后端不分离项目适合WEB项目，提高SEO能力
- 前后端分离项目时候多端项目，如同时有WEB和APP，如果服务器单独为APP开发接口，会加大工作量，前后端分离后，就不需要为APP单独增加工作量

## 7. 前端工程化

前端工程化是使用软件工程的技术和方法来进行前端项目的开发、维护和管理

就是形成一套规矩，把前端网站的制作标准化，大概分为以下措施：

- 模块化：把耦合在一起的大文件 拆分成功能独立的小文件，再进行统一的拼装和加载
- 组件化：代码的设计层面，把不同的功能解耦合，设计成可插拔的组件，相当于组装台式机
- 规范化：设定一个规范，让所有参与人员的代码统一风格，便于团队的协作
- 自动化：简单机械的重复工作，让程序自动完成，如脚手架

## 8. 浏览器的渲染顺序

1. 解析HTML，创建DOM树
2. 创建CSSOM树
3. 执行JavaScript
4. 生成渲染树
5. 生成布局
6. 渲染页面

------

# 工具篇

## 1. webpack

- 一种前端资源构建工具，一个静态模块打包器（nodule bundle）
- 前端所有资源文件（js/json/css/img…）都会作为模块处理
- 它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源（bundle）

## 2. Git中commit信息错误怎么修改

```shell
git commit --amend --message="modify message by daodaotest"
```

------

# 私人篇

## 1. 数据类型

​	基础类型数据：String/Number/Boolean/Undefined/Null/Symbol/BigInt

​	引用类型数据：Object/Array/Function/Date/RegExp

​	栈内存：存储 "基础类型数据" and "堆内存的地址"

​	堆内存：存储 "引用类型数据"

## 2. 预解析

​	"变量" and "具名函数" 声明提前

## 3. 执行上下文环境

​	1.在全局代码执行前，JS 引擎会创建一个栈来存储管理所有的执行上下文环境

​	2.先把全局上下文环境存放栈中，调用函数时会把该函数的上下文环境存放栈中

​	3.当函数执行完毕后，会移除该的函数上下文环境

​	4.当所有代码执行完毕后，栈中只剩下 window

​	5.执行上下文是动态的，尤其针对函数，每次调用一次函数就会创建一次函数执行上下文环境

## 4. 浅拷贝和深拷贝

​	浅拷贝：把当前对象的堆内存地址赋值给另一个变量

​	深拷贝：拷贝当前对象的内容给新的堆内存地址，再赋值给另一个变量

​	说明：无论是浅拷贝还是深拷贝，主要针对的是引用类型数据

## 5. 函数

​	回调函数：函数作为参数值，并在内部调用，称为回调函数

​	纯函数：1. 不能改变参数值的数据  2. 不能有任何副作用  3. 相同输入返回相同输出

​	高阶函数："参数" or "返回值" 是函数

​	函数柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式

​	说明：所有函数都是 Function 的实例对象

## 6. 原型链

​	原型：函数定义时产生 "显示原型"，对象定义时产生 "隐式原型"

​	原型链：多个 "隐式原型" 逐级继承形成的链式结构，称为原型链

​	说明：所有对象的 "隐式原型" 都是 Object.prototype

## 7. 作用域链

​	作用域：全局作用域 or 局部作用域 or 块级作用域(ES6：const/let)

​	作用域链：全局作用域和多个局部作用域形成的链式结构，称为作用域链

## 8. 面向对象

​	封装：创建一个对象并赋予该对象属性，用于管理及维护大量数据

​	继承：当前对象逐级继承 "隐式原型" 的所有属性，实现代码的复用性

​	多态：

​		重载：当前函数根据不同的参数产生不同的执行结果，从而实现重载

​		重写：当前对象定义一个和 "隐式原型" 同名的属性，JS 引擎会优先使用当前对象的属性执行，从而实现重写

## 9. 闭包

​	函数之前有嵌套关系，并且内部函数中引用了外部函数的变量；当调用外部函数从而使内部函数定义时，此时形成了闭包

## 10. 事件轮询机制

​	1.JS 是一门单线程语言，主线程会从上往下执行，此时是同步的环境

​	2.当主线程检测到异步操作时，就会把当前的异步任务交给其它异步线程处理，然后继续执行主线程的任务

​	3.异步任务分为 "宏任务" or "微任务"

​		宏任务：setTimeout、setInterval、Ajax、DOM事件

​		微任务：promise、async/await、process.nextTick

​	4. JS 引擎执行顺序："执行宏队列中第一个宏任务"  ->  "执行同步代码"  ->  "执行当前宏任务中的所有微任务"  ->  "渲染界	面"（循环此操作）

## 11. 回调地狱

​	层层嵌套的回调函数，称为 "回调地狱"

## 12. 工厂模式

​	通过函数的多次调用，根据传参值创建多个新对象并返回，称为工厂模式

## 13. 单例模式

​	不管单次或者多次调用函数，最终返回的对象只有一个

## 14. Worker

​	Worker 是一个构造函数，以一个文件为单位模拟多线程

​	API：

​		new Worker()：构造函数，加载分线程执行的 JS 文件

​		Worker.prototype.onmessage：用于接收另一个线程的回调函数

​		Worker.prototype.postMessage：向另一个线程发送消息

​	缺点：

​		1.兼容性问题，不是每个浏览器都支持这个新特性

​		2.Worker 内的代码不能操作 DOM（更新 UI ）

​		3.不能跨域加载 JS

## 15. pormise

​	1.Promise 是 JS 中进行异步编程的新方案

​	2.new Promise((resolve, reject)=>{}) 的时候，要传入一个同步的回调函数，它被称为 executor 函数

​	3.Promise 实例对象都有三种状态：pending、fulfilled、rejected

​	4.executor 函数会接收到两个参数，分别为：resolve、reject

​		resolve：调用 resolve，会让 Promise 实例对象状态变为：fulfilled

​		reject：调用 reject，会让 Promise 实例对象状态变为：rejected

​	优势：

​		① 更加灵活，Promise 实例对象可以随时随地的调用 then 回调

​		② 支持链式调用，可以解决回调地狱

​	语法糖：

​		async 修饰函数：

​			① 函数的返回值为 Promise 实例对象

​			② Promise 实例对象的结果由 async 函数的返回值决定

​		await 表达式：

​			① await 右侧的表达式为 Promise 实例对象，await 的返回值是 Promise 实例对象成功的值

​			② await 右侧的表达式为其他值，则直接将此值作为 await 的返回值

## 16. 事件冒泡/事件委托

​	事件冒泡：标签之前有嵌套关系，并且有相同或类似的事件触发，此时形成事件冒泡

​	事件委托：通过事件冒泡，把事件委托给父/祖元素处理，称为事件委托

## 17. TCP 连接

​	建立连接：

​		1.客户端发送建立连接请求

​		2.服务器端接收到该请求并发送响应信息

​		3.客户端接收到响应信息产生连接

​	断开连接：

​		1.客户端发送断开连接请求

​		2.服务器端接收到该请求

​		3.服务器端发送响应信息

​		4.客户端接收到响应信息断开连接

## 18. 节流 or 防抖

​	限制事件处理函数频繁调用可使用 "节流" or "防抖"

​	节流：首次触发事件后开始计算时间，期间无法重复触发该事件，直至时间结束后才能再次触发该事件

​		应用场景：1. 窗口调整（resize）  2. 页面滚动（scroll）  3. DOM 元素的拖拽功能实现（mousemove）  4. 抢购疯狂点击（click）

​	防抖：最后一次触发事件后开始计算事件，期间重复触发该事件会导致时间重新开始计算，时间结束后则开始执行内部代码

​		应用场景：输入框实时搜索（keyup/input）

## 19. 数据存储

​	sessionStorage/localStorage：

​		1.纯浏览器端存储, 大小不受限制, 请求时不会自动携带当前数据

​		2.只能保存文本, 如果是对象或数组, 需要转换为JSON

​		sessionStorage：数据保存在当前会话内存中, 关闭浏览器则清除

​		localStorage：保存在本地文件中, 除非编码或手动删除, 否则一直存在

​	cookie：

​		1.存储在浏览器端的文本数据（最大4KB），会随着请求一起发送到服务器端

​		2.本身用于浏览器和服务器之间的通讯

​		缺点：

​			① 存储大小限制4KB

​			② HTTP 请求时会自动把该数据发送给服务器, 增加了请求的数据量

​	token：

​		1. token 是认证令牌

​		2.用户登录成功后，服务器通过一些加密算法把用户信息、token的有效期等，加密成一个字符串，然后发送给用户，这个字符串就是 token

​		3.加密算法只有服务器知道，服务器可以对 token 进行解密，还原成原始值

​		4.用户每次请求都必须携带 token，服务器直接解密 token 就可以知道用户的相关信息，省去查询数据库的操作，减轻数据库的压力

## 20. MVVM 和 MVC 区别

​	MVVM：MVVM 可以通过 ViewModel 层代替 View 进行交互，从而实现数据的双向绑定，并且V和VM可以进行通信

​	MVC：View一般通过Controller来和Model进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下

## 21. VUE路由三种模式

​	hash：url 携带 # 号，当 url 改变时，页面不会重新加载
​	history：url 不携带 # 号，当 url 改变时，页面用已改变的 url 会重新加载导致报404错误，可通过 vue.config.js 配置进行解决
​	abstract：适用于所有 JavaScript 环境，例如服务器端使用Node.js。如果没有浏览器API，路由器将自动被强制进入此模式
